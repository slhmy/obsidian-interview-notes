大部分内容参考于
[跨站请求伪造—CSRF](https://juejin.cn/post/6844904004288249870)，
我觉得写的还是挺清楚的。

>通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，
>在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，
>从而在并未授权的情况下执行在权限保护之下的操作。

简单来说，就是有恶意的第三方网站，知道了我方站点 API 的请求方式，
利用浏览器在请求时会自动携带 Cookie 的特性，在用户访问该网站时，
通过自动向我方网站发送请求来实现未经用户允许的操作。

# 特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。
- 攻击是利用受害者在被攻击网站的登录凭证，冒充受害者提交操作，仅仅是“冒用”，而不是直接窃取数据。
- 攻击者预测出被攻击的网站接口的所有参数，成功伪造请求。

# 防御方法

CSRF 的防御方法本质上也是要对请求来源的可信度进行判断,
[CSRF漏洞原理攻击与防御（非常细）](https://blog.csdn.net/qq_43378996/article/details/123910614)
这篇文章里防御方法的优缺点会写的更详细一些

## SameSite 属性

要求用户使用支持 SameSite Cookie 属性的浏览器。
可用的防御属性有 Strict / Lax，
Lax 是现在浏览器最常见的默认设置，在 Strict 的基础上允许导航到本站的 GET 请求。

## 同源检测

- 参考 HTTP 头中的 Origin / Referer 来进行判断，
  但和上面的 SameSite 属性一样，都依赖于使用安全的浏览器
- 如果合适，可以通过验证码强制使用户进行一些手动操作，
  但并非适合所有场景。

## Token 验证

后端返回请求的前端页面时，可以在元素里塞一个可以用于判断会话是否可信的 Token。
前端在发送其它请求的时候，就可以带着这个 Token 来证明自己的身份。

这种防御方式对前端的实现有一定要求，会增添一些工作量。

Token 需要随机，不可以被伪造；
要有一定的有效期，其实就跟 Cookie 要有有效期一样;
并且应当是只在用户 Cookie 有效时添加 CSRF Token，
否则黑客可以在未登录状态下访问页面，并获取一个等效的 CSRF Token。
而当用户 Cookie 有效时，黑客无法直接在页面读取 Cookie 和本站的页面内容，
也就没法获取 CSRF Token 了。
